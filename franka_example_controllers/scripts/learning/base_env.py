
# import gym
# import rospy
# from gym.utils import seeding

# class BaseEnv(gym.Env):
#     """
#     Description:
#         For any given state the agent sets the Impedance Gains
#         (stiffness, damping) continuous values.

#     Observation:
#         Type: Box(13)
#         Num        Observation                      Min            Max
#         0 - 5      Joints position error, Q_ERR    X_MIN          X_MAX
#         6 - 11     Joints velocity error, V_ERR    V_MIN          V_MAX
#         12         Contact Force, F                F_MIN          F_MAX
#         13         Desired Contact Force, F_DES    F_MIN          F_MAX

#     Actions:
#         Type: Box(2)
#         Num       Action                     Min            Max
#         0         Impedance stiffness, K    K_MIN          K_MAX
#         1         Impedance damping, D      D_MIN          D_MAX

#     Reward:
#         Reward                       Condition
#         1 - |F_DES - F| / F_DES                0.9 * F_DES < F < 1.1 * F_DES
#         -1 * |F_DES - F| / F_DES     Else

#     Initial State:
#         Q_ERR = 0
#         V_ERR = 0
#         F = 0
#         F_DES = INITIAL_F_DES

#     Episode Termination:
#         Fixed trajectory length

#     """


import rospy
import gym
from gym.utils import seeding
from controllers_connection import ControllersConnection

class BaseEnv(gym.Env):

    def __init__(self, robot_name_space, controllers_list, reset_controls, start_init_physics_parameters=True, reset_world_or_sim="SIMULATION"):

        rospy.logdebug("START init BaseEnv")
        self.controllers_object = ControllersConnection(namespace=robot_name_space, controllers_list=controllers_list)
        self.reset_controls = reset_controls
        self.seed()

        rospy.logdebug("END init BaseEnv")

    # Env methods
    def seed(self, seed=None):
        self.np_random, seed = seeding.np_random(seed)
        return [seed]

    def step(self, action):
        """
        Function executed each time step.
        Here we get the action execute it in a time step and retrieve the
        observations generated by that action.
        :param action:
        :return: obs, reward, done, info
        """

        """
        Here we should convert the action num to movement action, execute the action in the
        simulation and get the observations result of performing that action.
        """
        rospy.logdebug("START STEP ROS")
        
        self._set_action(action)
        obs = self._get_obs() 
        done = self._is_done(obs)
        info = {}
        reward = self._compute_reward(obs, done)

        rospy.logdebug("END STEP ROS")

        return obs, reward, done, info

    def reset(self):
        rospy.logdebug("Reseting BaseEnv")
        self._init_env_variables()
        obs = self._get_obs()
        rospy.logdebug("END Reseting BaseEnv")
        return obs

    def close(self):
        """
        Function executed when closing the environment.
        Use it for closing GUIS and other systems that need closing.
        :return:
        """
        rospy.logdebug("Closing BaseEnv")
        rospy.signal_shutdown("Closing BaseEnv")

    def _reset_sim(self):
        """Resets a simulation
        """
        rospy.logdebug("RESET SIM START")
        if self.reset_controls :
            rospy.logdebug("RESET CONTROLLERS")
            self.controllers_object.reset_controllers()
            self._check_all_systems_ready()
            self._set_init_pose()
            self.controllers_object.reset_controllers()
            self._check_all_systems_ready()
        else:
            rospy.logwarn("DONT RESET CONTROLLERS")
            self._check_all_systems_ready()
            self._set_init_pose()
            self._check_all_systems_ready()
        
        rospy.logdebug("RESET SIM END")
        return True

    def _set_init_pose(self):
        """Sets the Robot in its init pose
        """
        raise NotImplementedError()

    def _check_all_systems_ready(self):
        """
        Checks that all the sensors, publishers and other simulation systems are
        operational.
        """
        raise NotImplementedError()

    def _get_obs(self):
        """Returns the observation.
        """
        raise NotImplementedError()

    def _init_env_variables(self):
        """Inits variables needed to be initialised each time we reset at the start
        of an episode.
        """
        raise NotImplementedError()

    def _set_action(self, action):
        """Applies the given action to the simulation.
        """
        raise NotImplementedError()

    def _is_done(self, observations):
        """Indicates whether or not the episode is done ( the robot has fallen for example).
        """
        raise NotImplementedError()

    def _compute_reward(self, observations, done):
        """Calculates the reward to give based on the observations given.
        """
        raise NotImplementedError()

    def _env_setup(self, initial_qpos):
        """Initial configuration of the environment. Can be used to configure initial state
        and extract information from the simulation.
        """
        raise NotImplementedError()